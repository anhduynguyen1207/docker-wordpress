// サイトの基本的な機能（header, トップぺ戻るなど）

let body = document.querySelector("body");

const fadeOut = (material, ms) => {
    material.style.opacity = 1;
    material.style.transition = "opacity " + ms + "ms";
    setTimeout(() => {
        material.style.opacity = 0;
    }, 1);
    setTimeout(() => {
        material.style.display = "none";
    }, ms + 10);
};

const fadeIn = (material, ms) => {
    material.style.opacity = 0;
    material.style.transition = "opacity " + ms + "ms";
    setTimeout(() => {
        material.style.opacity = 1;
    }, 1);
    setTimeout(() => {
        material.style.display = "block";
    }, ms + 10);
};

class Common {
    constructor(header, gNav, ms, returnBtn, scrollAmount) {
        this.header = header;
        this.gNav = gNav;
        this.ms = ms;
        this.returnBtn = returnBtn;
        this.scrollAmount = scrollAmount;
    }

    // 上に戻るボタン
    returnAbove() {
        let timer = null;
        const returnBtn = document.querySelectorAll(this.returnBtn);
        const returnAboveTimer = () => {
            clearTimeout(timer);
            timer = setTimeout(() => {
                if (window.scrollY > this.scrollAmount) {
                    //フェードインで表示
                    fadeIn(returnBtn[0], this.ms);
                } else {
                    fadeOut(returnBtn[0], this.ms);
                }
            }, 16);
        };

        document.addEventListener("scroll", returnAboveTimer, {
            passive: true,
        });

        returnBtn[0].addEventListener("click", () => {
            window.scrollTo({ top: 0, behavior: "smooth" });
        });
    }

    navFunction() {
        // Nav Toggle Button
        const toggle = document.querySelectorAll(".box-nav-toggle");
        let headerContent = document.getElementById(this.header);
        let gNav = document.getElementById(this.gNav);
        let ms = this.ms;
        let scrollPos;

        toggle[0].addEventListener(
            "click",
            (e) => {
                headerContent.classList.toggle("open");
                if (body.classList.contains("fix")) {
                    console.log(body.classList.contains("fix"));
                    body.classList.remove("fix");
                    body.style.cssText = "top: 0";
                    window.scrollTo(0, scrollPos);
                    fadeOut(gNav, ms);
                } else {
                    scrollPos = window.scrollY;
                    body.classList.add("fix");
                    body.style.cssText = "top:" + -scrollPos + "px";
                    fadeIn(gNav, ms);
                }
            },
            false
        );
    }
}

// コンテンツフェードイン機能
class ContentsFade {
    constructor(className, timing, visibleclassName) {
        this.className = className;
        this.timing = timing;
        this.visibleclassName = visibleclassName;
    }

    fadeIn() {
        let targets = document.querySelectorAll(this.className);
        let timing = this.timing;
        let positionStart;
        let scrollAmount;
        let offset;
        let windowHeight;
        window.addEventListener("scroll", () => {
            for (let num = 0; num < targets.length; num++) {
                positionStart = targets[num].getBoundingClientRect().top;
                scrollAmount = window.pageYOffset || document.documentElement.scrollTop; // amount of scroll in real || just in time, one of scroll position.
                offset = positionStart + scrollAmount;
                windowHeight = window.innerHeight;

                if (scrollAmount > offset - windowHeight + timing) {
                    targets[num].classList.add(this.visibleclassName);
                }
            }
        });
    }
}

// scrollMagic 縦スクロールフェードイン・アウト
class ScrollFadeIn {
    constructor(scroll_box, anime_box, scroll_section, animation_section) {
        this.scroll_box = document.querySelectorAll(scroll_box);
        this.anime_box = document.querySelectorAll(anime_box);
        this.scroll_section = scroll_section;
        this.animation_section = animation_section;

        if (this.scroll_box.length === null) {
            return;
        }

        let scene;

        let controller = new ScrollMagic.Controller();
        for (let i = 0; i < this.scroll_box.length; i++) {
            const getDurationA = () => {
                let h_plus = 0;
                if (i == 8) {
                    h_plus = 500;
                }
                return this.scroll_box[i].offsetHeight + h_plus;
            };
            scene = new ScrollMagic.Scene({
                triggerElement: this.scroll_box[i],
                duration: getDurationA,
                reverse: true,
                triggerHook: "1",
            })
                .setClassToggle(this.anime_box[i], "active")
                .addIndicators()
                .addTo(controller);
        }

        const getDurationB = () => {
            return scroll_section.offsetHeight - 800;
        };

        scene = new ScrollMagic.Scene({
            triggerElement: scroll_section,
            triggerHook: 0,
            duration: getDurationB,
        })
            .setPin(animation_section)
            .addIndicators()
            .addTo(controller);
    }
}
